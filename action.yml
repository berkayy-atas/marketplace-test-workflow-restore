name: 'Repository Restore'
description: 'Restores a backed-up GitHub repository using secure OTP and file ID through File Security API.'
author: 'your-github-username'

inputs:
  activation_code:
    description: 'Activation code for API'
    required: true
  encryption_password:
    description: 'Secret key for decrypting the backup'
    required: true
  otp_code:
    description: 'One time password for restore repository.'
    required: true
  file_version_id:
    description: 'Enter FILE_VERSION_ID to retrieve a specific backup file.'
    required: true
    default: ''
  restore_github_token:
    description: 'Optional: Token to restore workflows (if provided, full mirror restore with workflows).'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Validate encryption password length
      shell: bash
      run: |
        ENC_PASS="${{ inputs.encryption_password }}"
        if [ "${#ENC_PASS}" -lt 32 ]; then
          echo "::error ::The encryption_password must be at least 32 characters long (got ${#ENC_PASS})."
          exit 1
        fi
        
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Cache OTP Session
      id: cache-otp
      uses: actions/cache@v3
      with:
        path: .github/file-security-cache
        key: otp-session-${{ github.repository_id }}-${{ github.run_id }}
        restore-keys: |
          otp-session-${{ github.repository_id }}-
          otp-session-

    - name: Initialize cache directory
      shell: bash
      run: |
        if [ ! -d ".github/file-security-cache" ]; then
          echo "::debug::Cache directory not found, creating..."
          mkdir -p ".github/file-security-cache"
          echo "CACHE_VALID=false" >> $GITHUB_ENV
        else
          echo "::debug::Cache directory already exists"
        fi

    - name: Check for cached uniqueKey
      id: check_cache
      shell: bash
      run: |
        
        if [ ! -d ".github/file-security-cache" ]; then
          echo "::warning :: Cache directory not found!!!"
          echo "CACHE_VALID=false" >> $GITHUB_ENV
          exit 1
        fi

        # fileCreatedTime dosyası var mı kontrol et
        if [ ! -f ".github/file-security-cache/fileCreatedTime" ]; then
          echo "::debug::fileCreatedTime not found in cache"
          echo "CACHE_VALID=false" >> $GITHUB_ENV
          exit 0
        fi
        
        # Check cache age (90 seconds)
        NOW=$(date +%s)
        FILE_TIME=$(cat .github/file-security-cache/fileCreatedTime)
        AGE=$((NOW - FILE_TIME))
        OTP=${{ inputs.otp_code }}
          
        if [ "$AGE" -gt 80 ] || [ -z "$OTP"  ]; then
          if [ "$AGE" -gt 80 ]; then
            echo "::warning ::OTP session expired. Removing cache. Please repeat the steps."
          else
            echo "::warning ::OTP value not entered, a new OTP session is being created."
          fi
          echo "CACHE_VALID=false" >> $GITHUB_ENV
        else
          echo "UNIQUE_KEY=$(cat .github/file-security-cache/uniqueKey)" >> $GITHUB_ENV
          echo "CACHE_VALID=true" >> $GITHUB_ENV
        fi
        
    - name: Cache Provided file_version_id
      if: ${{ inputs.file_version_id != '' }}
      shell: bash
      run: |
        echo "A file_version_id was provided, caching it: ${{ inputs.file_version_id }}"
        echo "${{ inputs.file_version_id }}" > .github/file-security-cache/fileVersionId
        echo "fileVersionIdCached=true" >> $GITHUB_ENV

    - name: Get Activation Token
      id: get_token
      shell: bash
      run: |
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://dev.api.file-security.icredible.com/endpoint/activation" \
        -H "Content-Type: application/json" \
        -d '{
          "activationCode": "${{ inputs.activation_code }}",
          "uniqueId": "${{ github.repository_id }}",
          "ip": "${{ runner.ip }}",
          "operatingSystem": "Linux",
          "endpointType": "Workstation",
          "endpointName": "Github Endpoint (${{ github.repository }})"
        }')

        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        JSON_BODY=$(echo "$RESPONSE" | head -n -1)

        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "Failed to get token" && exit 1
        fi

        TOKEN=$(echo "$JSON_BODY" | jq -r '.data.token')
        echo "TOKEN=$TOKEN" >> $GITHUB_ENV

    - name: Request and Cache OTP if needed
      if: ${{ env.CACHE_VALID != 'true' && inputs.otp_code == '' }}
      shell: bash
      run: |
        echo "Requesting OTP..."
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "https://dev.api.file-security.icredible.com/OTP/Send" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer ${{ env.TOKEN }}" \
          -d '{
            "Source": "FileDownload",
            "OtpGenerationMode": "Number",
            "Type": "MAIL"
          }')

        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        JSON_BODY=$(echo "$RESPONSE" | head -n -1)
        echo "HTTP STATUS: $HTTP_STATUS"

        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "::error :: OTP request failed. Status: $HTTP_STATUS"
          echo "Message: $(echo "$JSON_BODY" | jq -r '.message // .error // .msg // .description // "No error message provided"')"
          exit 1
        fi

        UNIQUE_KEY=$(echo "$JSON_BODY" | jq -r '.data.uniqueKey')
        echo "UNIQUE_KEY=$UNIQUE_KEY" >> $GITHUB_ENV

        if [ ! -f ".github/file-security-cache/fileVersionId" ]; then
            echo "::notice title=Action Required::✔️ OTP has been sent to your email. Please re-run the workflow with the OTP code and the file_version_id."
        else
            echo "::notice title=Action Required::✔️ OTP has been sent to your email. Please re-run the workflow with the received OTP code to continue."
        fi
        exit 0


    - name: Save the UNIQUE_KEY
      if: ${{ env.CACHE_VALID != 'true' && inputs.otp_code == '' }}
      shell: bash
      run: |
        # Save to cache with description
        cat <<EOF > .github/file-security-cache/README.md
        # OTP Session Cache
        This file is automatically used by the restore action during second run.
        Please do not modify this file manually.
        
        Generated at: $(date)
        Repository: ${{ github.repository }}
        Run ID: ${{ github.run_id }}
        EOF
        echo "$UNIQUE_KEY" > .github/file-security-cache/uniqueKey
        date +%s > .github/file-security-cache/fileCreatedTime
        echo "CACHE_EXISTS=true" >> $GITHUB_ENV
        echo "OTP requested. UniqueKey cached. Please re-run with OTP."
        
        echo "::notice :: ✔️ OTP requested but not provided. Check email and re-run with otp_code."
        exit 0

    - name: Validate OTP Session
      if: ${{ env.CACHE_EXISTS == 'true' && inputs.otp_code != '' }}
      shell: bash
      run: |
        NOW=$(date +%s)
        FILE_TIME=$(cat .github/file-security-cache/fileCreatedTime)
        AGE=$((NOW - FILE_TIME))
          
        if [ "$AGE" -gt 85 ]; then
          echo "::error ::OTP session expired. Please restart the process."
          exit 0
        else
          echo "CACHE_VALID=true" >> $GITHUB_ENV
        fi
        
    - name: Retrieve Backup
      if: ${{ (env.CACHE_VALID == 'true' || env.CACHE_VALID == '') && inputs.otp_code != '' }}
      shell: bash
      run: |
        
        # Önbellekten file_version_id'yi oku
        CACHED_FILE_ID=""
        if [ -f ".github/file-security-cache/fileVersionId" ]; then
          CACHED_FILE_ID=$(cat .github/file-security-cache/fileVersionId)
        fi
        
        # Eğer önbellekte ID yoksa, işlem başarısız olur.
        if [ -z "$CACHED_FILE_ID" ]; then
          echo "::error::File Version ID is required to restore. It was not provided in this run or a previous one. Please provide a file_version_id and try again."
          exit 1
        fi
        
        echo "Attempting to retrieve backup with File Version ID: $CACHED_FILE_ID"
        RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "https://dev.api.file-security.icredible.com/restore/$CACHED_FILE_ID" \
        -H "Authorization: Bearer ${{ env.TOKEN }}" \
        -H "X-Verification-Key: ${{ inputs.otp_code }}" \
        -H "X-Unique-Key: ${{ env.UNIQUE_KEY }}"  -o repo.tar.zst.enc)
        echo "Raw API Response: $RESPONSE"
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        JSON_BODY=$(echo "$RESPONSE" | head -n -1)
        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "Failed to obtain backup file. Response: $RESPONSE"
          echo "Error: Received HTTP status $HTTP_STATUS"
          echo "Response: $JSON_BODY"
          exit 1
        fi
        echo "Backup file retrieved successfully."

    - name: Decrypt and Extract Backup
      if: ${{ inputs.otp_code != '' }}
      shell: bash
      run: |
        echo "Decrypting repository"
        openssl enc -d -aes-256-cbc -pbkdf2 -in repo.tar.zst.enc -out repo.tar.zst -pass pass:${{ inputs.encryption_password }}
        echo "Extracting repository backup..."        
        zstd -d repo.tar.zst -o repo.tar
        tar -xf repo.tar
        rm -f repo.tar repo.tar.zst
        
        # Mirror dizinini bul ve yeniden adlandır
        if [ -d "repo-mirror" ]; then
          echo "Found repo-mirror directory"
        else
          # Mirror dizinini bul (adı farklı olabilir)
          mirror_dir=$(find . -maxdepth 1 -type d -name "*mirror*" | head -1)
          if [ -n "$mirror_dir" ]; then
            mv "$mirror_dir" repo-mirror
          else
            # Eğer mirror dizini yoksa, mevcut dizini mirror olarak kabul et
            echo "No mirror directory found, using current directory as repo-mirror"
            mkdir -p repo-mirror
            mv * .[^.]* repo-mirror/ || true
          fi
        fi
        
        echo "Decryption and extraction complete."
    

    - name: Configure Git and Push
      if: ${{ inputs.otp_code != '' }}
      shell: bash
      run: |
        cd repo-mirror
       
        if [ -z "${{ inputs.restore_github_token }}" ]; then
          TOKEN_TO_USE="${{ github.token }}"
        else
          TOKEN_TO_USE="${{ inputs.restore_github_token }}"
        fi
        
        git config user.name "myapp File Security"
        git config user.email "file-security@myapp.com"
        git remote set-url origin https://x-access-token:${TOKEN_TO_USE}@github.com/${{ github.repository }}.git

        echo "--- Pushing all branches ---"
        # --all: Tüm yerel dalları uzak sunucuya gönderir.
        # --force: Uzak sunucudaki geçmişin, bizim yedeğimizdeki geçmişle tam olarak aynı olmasını sağlar.
        # || true: Olası "pull request ref" gibi hataları yoksayarak adımın başarılı sayılmasını sağlar.
        git push origin --all --force || true
        
        echo "--- Pushing all tags ---"
        # --tags: Tüm etiketleri (tags) uzak sunucuya gönderir.
        # --force: Uzak sunucudaki etiketlerin üzerine yazar.
        git push origin --tags --force || true
        
        echo "Repository restore process completed."
